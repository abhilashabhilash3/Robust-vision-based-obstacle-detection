import os
import cv2
import numpy as np
from datetime import datetime

import matplotlib.pyplot as plt

import scipy.stats as stats
from scipy.ndimage.morphology import generate_binary_structure, grey_erosion, grey_dilation

import consts

from common import utils, logger, ImageLocationUtility, PatchArray

class Visualize(object):
    WINDOWS_IMAGE = "visualize_image"
    WINDOWS_CONTROLS = "visualize_controls"
    WINDOWS_MAHA = "visualize_maha"

    DIRECTION_TEXTS = {
        -1: "Not set",
        0: "Unknown",
        1: "CCW",
        2: "CW"
    }

    DIRECTION_COLORS = {
        -1: (100, 100, 100),   # Not set
        0: (255,255,255),     # Unknown
        1: (136, 150, 0),     # CCW
        2: (0, 152, 255)      # CW
    }

    def image_write_label(self, image, frame):
        """Write the specified label on an image for debug purposes
        (0: Unknown, 1: No anomaly, 2: Contains an anomaly)
        
        Args:
            image (Image): Image object
            frame (PatchArray): Current frame
        """
        
        font                   = cv2.FONT_HERSHEY_SIMPLEX
        fontScale              = 0.5
        thickness              = 1

        cv2.putText(image, self.title,
            (10,20), # bottomLeftCornerOfText
            font,
            fontScale,
            (255,255,255),
            thickness, lineType=cv2.LINE_AA)
        
        cv2.putText(image,"Label: ",
            (10,50), # bottomLeftCornerOfText
            font,
            fontScale,
            (255,255,255),
            thickness, lineType=cv2.LINE_AA)

        cv2.putText(image, self.metric.names.get(frame[self.metric.label_name], 0),
            (60, 50),
            font,
            fontScale,
            PatchArray.Metric.COLORS.get(frame[self.metric.label_name], 0),
            thickness, lineType=cv2.LINE_AA)

        if self._video_writer is None:
            if frame.directions != 0:
                cv2.putText(image,"Direction: ",
                    (10,80), # bottomLeftCornerOfText
                    font,
                    fontScale,
                    (255,255,255),
                    thickness, lineType=cv2.LINE_AA)
                
                cv2.putText(image, Visualize.DIRECTION_TEXTS.get(frame.directions, 0),
                    (90, 80),
                    font,
                    fontScale,
                    Visualize.DIRECTION_COLORS.get(frame.directions, 0),
                    thickness, lineType=cv2.LINE_AA)

            if frame.round_numbers != 0:
                cv2.putText(image,"Round: ",
                    (10,110), # bottomLeftCornerOfText
                    font,
                    fontScale,
                    (255,255,255),
                    thickness, lineType=cv2.LINE_AA)
                
                cv2.putText(image, str(frame.round_numbers),
                    (65, 110),
                    font,
                    fontScale,
                    (255,255,255),
                    thickness, lineType=cv2.LINE_AA)

    @staticmethod
    def image_add_trackbar(image, index, patches):
        """Add trackbar to image
        
        Args:
            image (Image)
            index (int): Current index
            patches (PatchArray)
        """
        
        width = image.shape[1]
        # factor = patches.shape[0] / float(width)
        
        slots, factor = np.linspace(0, patches.shape[0], num=width, endpoint=False, dtype=np.int, retstep=True)

        def _get_round_number_color(round_number):
            if round_number <= 0:
                return (255, 255, 255)
            elif round_number % 2 == 0:
                return (181, 81, 63)
            elif round_number % 2 == 1:
                return (203, 134, 121)

        image[210:217, ...] = np.array(np.vectorize(PatchArray.Metric.COLORS.get)(patches[slots, 0, 0].labels)).T
        image[217:225, ...] = np.array(np.vectorize(PatchArray.Metric.COLORS.get)(patches[slots, 0, 0].stop)).T
        image[255:270, ...] = np.array(np.vectorize(Visualize.DIRECTION_COLORS.get)(patches[slots, 0, 0].directions)).T
        image[300:315, ...] = np.array(np.vectorize(_get_round_number_color)(patches[slots, 0, 0].round_numbers)).T

        image[210:225, int(index / factor), :] = (1, 1, 1)
        image[255:270, int(index / factor), :] = (1, 1, 1)
        image[300:315, int(index / factor), :] = (1, 1, 1)

    def __init__(self, patches, **kwargs):
        """Visualize patches

        Args:
            patches (PatchArray): Array of patches
            images_path (str): Path to jpgs (Default: consts.IMAGES_PATH)
            show_grid (bool): Overlay real world coordinate grid (Default: False)
            show_map (bool): Update the position on the map every frame (Default: False)
            show_values (bool): Show values on each patch (Default: False)
        """
        self.orig_patches = patches
        self.patches      = patches
        self.images_path = kwargs.get("images_path", consts.IMAGES_PATH)

        self.show_grid = kwargs.get("show_grid", False)
        self.show_map  = kwargs.get("show_map", False)
        self.show_values  = kwargs.get("show_values", False)
        
        self.key_func            = kwargs.get("key_func", None)

        self.model_index = 0 # Index for patch_to_color_func ...

        self.index = 0
        self.pause = True
        
        if self.patches.contains_mahalanobis_distances:
            self._metrics_fig, self._metrics_ax1 = plt.subplots(1, 1)
            self._metrics_ax1.set_yscale("log")
            # self._metrics_ax2 = self._metrics_ax1.twinx()

            # mng = plt.get_current_fig_manager()
            # mng.full_screen_toggle()

            self._histogram_fig, (self._histogram_ax1, self._histogram_ax2) = plt.subplots(2, 1, sharex=True)

            self._histogram_ax1.set_title("No anomaly")
            self._histogram_ax2.set_title("Anomaly")
            
            self._histogram_fig.suptitle("Mahalanobis distances")

            
            self._metrics_fig.show()
            self._histogram_fig.show()
        
        if self.patches.contains_locations:
            # Setup map display
            self.extent = patches.get_extent()
            
            self._map_fig = plt.figure()
            self._map_ax = self._map_fig.add_subplot(111)
            self._map_ax.set_xlim([self.extent[0], self.extent[2]])
            self._map_ax.set_ylim([self.extent[1], self.extent[3]])

            # Calculate grid overlay
            self._ilu = ImageLocationUtility()
            self._absolute_locations = self._ilu.span_grid(self.extent[3] - self.extent[1], self.extent[2] - self.extent[0],
                                                                   offset_y=self.extent[1],         offset_x=self.extent[0])

            self._map_fig.show()
        else:
            self.show_grid = False
            self.show_map = False

        plt.ion()

        self._prev_gray = None
        self._cur_glitch = None

        self._labels = None
        self._scores = None
        self._thresh = None

        self._assets_path = os.path.join(os.path.dirname(__file__), "assets")

        self._window_set_up = False
        self.mode = 0 # 0: don't edit, 1: single, 2: continuous
        self._label = -1
        self._direction = -1
        self._round_number = -1
        self._last_index = 0
        self._exiting = False
        self._mouse_down = False

        self._mouse_image_x = -1
        self._mouse_image_y = -1
        self._image_shape = (1, 1, 3)

        self._video_writer = None

    def show(self):
        """ Main function """
        self.mode = 0 # 0: don't edit, 1: single, 2: continuous
        self._label = -1
        self._direction = -1
        self._round_number = -1
        self._last_index = 0
        self._exiting = False
        self._mouse_down = False


        self.__setup_window__()
        self.__draw__()
        plt.show()#block=False)

        while True:
            # plt.draw()
            plt.pause(0.001)

            key = cv2.waitKey(cv2.getTrackbarPos("delay", self.WINDOWS_CONTROLS))
            
            if key == 27:    # [esc] => Quit
                if self._exiting:
                    self._exiting = False
                    self.__draw__()
                elif len(self.orig_patches.metadata_changed) > 0:
                    self.pause = True
                    self._exiting = True
                    self.__draw__()
                else:
                    return self.close()
            elif key == ord("y") and self._exiting: # [y] => save changes
                if self.orig_patches.save_metadata():
                    return self.close()
            elif key == ord("n") and self._exiting: # [n] => save changes
                return self.close()
            elif key == ord("5"): # [5] => extract current patches
                self.patches.extract_current_patches()
            elif key == ord("r"): # [r] => start/stop recording video
                self.record()
            elif key == ord(" "):  # [space] => Pause
                self.pause = not self.pause
                continue
            elif key == ord("d"): # [d] => Seek forward + pause
                self.index += 1
                self.pause = True
            elif key == ord("a"):  # [a] => Seek backward + pause
                self.index -= 1
                self.pause = True
            elif key == ord("e"): # [e] => Seek 20 forward
                self.index += 20
            elif key == ord("q"): # [q] => Seek 20 backward
                self.index -= 20
            elif key == -1 and not self.pause:  # No input, continue
                self.index += cv2.getTrackbarPos("skip", self.WINDOWS_CONTROLS)

            if self.index >= self.patches.shape[0] - 1:
                self.index = self.patches.shape[0] - 1
                self.pause = True
            elif self.index <= 0:
                self.index = 0
                self.pause = True

            if self.key_func is not None:
                self.key_func(key)

            
            if key == ord("s"):  # [s]   => Switch single / continuous mode
                self.mode += 1
                if self.mode == 3:
                    self.mode = 0
                    self._label = -1
                    self._direction = -1
                    self._round_number = -1
                self.__draw__()
            
            if self.mode > 0:
                if   key == ord("0"): # [0]   => Unknown
                    new_label = 0
                elif key == ord("1"): # [1]   => No anomaly
                    new_label = 1
                elif key == ord("2"): # [2]   => Contains anomaly
                    new_label = 2

                elif key == ord("#"): # [#]   => Direction unknown
                    new_direction = 0
                elif key == ord(","): # [,]   => Direction is CCW
                    new_direction = 1
                elif key == ord("."): # [.]   => Direction is CW
                    new_direction = 2

                elif key == ord("+"): # [+]   => Increase round number by 1
                    new_round_number = self._round_number + 1
                elif key == ord("-"): # [-]   => Decrease round number by 1
                    new_round_number = self._round_number - 1
                    if new_round_number <= -1: new_round_number = -1
                elif key == ord("x"):# [x]   => Don't set the round number
                    new_round_number = -1
                
                # If we skipped back
                if self.index < self._last_index:
                    self._last_index = self.index
                
                indices = range(self._last_index, self.index + 1)
                self._last_index = self.index
                
                # Label the last frames if in continuous mode
                if self.mode == 2:
                    for i in indices:
                        if self._label != -1:
                            self.patches[i, 0, 0].stop = self._label
                        
                        if self._direction != -1:
                            self.patches[i, 0, 0].directions = self._direction

                        if self._round_number != -1:
                            self.patches[i, 0, 0].round_numbers = self._round_number

                if key == ord("0") or key == ord("1") or key == ord("2"):
                    if new_label == self._label:
                        new_label = -1
                    elif new_label != -1:
                        self.patches[self.index, 0, 0].stop = new_label
                    self._label = new_label
                    self.__draw__()
                    
                if key == ord("#") or key == ord(",") or key == ord("."):
                    if new_direction == self._direction:
                        new_direction = -1
                    elif new_direction != -1:
                        self.patches[self.index, 0, 0].directions = new_direction
                    self._direction = new_direction
                    self.__draw__()
                    
                if key == ord("+") or key == ord("-") or key == ord("x"):
                    if new_round_number != -1:
                        self.patches[self.index, 0, 0].round_numbers = new_round_number
                    self._round_number = new_round_number
                    self.__draw__()
                
                if self.mode == 1:
                    self._label = -1
                    self._direction = -1
                    self.__draw__()

            # Update trackbar and thus trigger a draw
            cv2.setTrackbarPos("index", self.WINDOWS_CONTROLS, self.index)

    def create_trackbar(self, name, default, max):
        self.__setup_window__()
        cv2.createTrackbar(name, self.WINDOWS_CONTROLS, default, max, self.__draw__)

    def get_trackbar(self, name):
        return cv2.getTrackbarPos(name, self.WINDOWS_CONTROLS)
    
    def __maha__(self, x=None, only_refresh_image=False):
        image = np.zeros((350, 480, 3), dtype=np.uint8)
        if self.model_index > 0 and self.patches.contains_mahalanobis_distances:
            font                   = cv2.FONT_HERSHEY_SIMPLEX
            fontScale              = 0.5
            thickness              = 1

            model = sorted(self.patches.mahalanobis_distances.dtype.names)[self.model_index - 1]
            print(model)

            cv2.putText(image,"Model:", (10, 20), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)
            cv2.putText(image, model,    (65, 20), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)

            cv2.putText(image,"Filter:", (10, 50), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)

            if not only_refresh_image:
                self.patches.mahalanobis_distances_filtered[:] = self.patches.mahalanobis_distances[model]

            sigma_0 = (cv2.getTrackbarPos("0_gaussian_0", self.WINDOWS_MAHA),
                       cv2.getTrackbarPos("0_gaussian_1", self.WINDOWS_MAHA),
                       cv2.getTrackbarPos("0_gaussian_2", self.WINDOWS_MAHA))
            if sigma_0 != (0, 0, 0):
                cv2.putText(image, "gaussian (%i, %i, %i)" % sigma_0, (65, 50), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)
                if not only_refresh_image:
                    self.patches.mahalanobis_distances_filtered = utils.gaussian_filter(self.patches.mahalanobis_distances_filtered, sigma=sigma_0)

            erosion_dilation = cv2.getTrackbarPos("1_erosion_dilation", self.WINDOWS_MAHA)
            if erosion_dilation > 0:
                struct = generate_binary_structure(cv2.getTrackbarPos("1_erosion_dilation_structure_rank", self.WINDOWS_MAHA),
                                                   cv2.getTrackbarPos("1_erosion_dilation_structure_connectivity", self.WINDOWS_MAHA))
                if struct.ndim == 2:
                    z = np.zeros_like(struct, dtype=np.bool)
                    struct = np.stack((z, struct, z))
                
                if erosion_dilation == 1:
                    cv2.putText(image, "erosion", (65, 80), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)
                    if not only_refresh_image:
                        self.patches.mahalanobis_distances_filtered = grey_erosion(self.patches.mahalanobis_distances_filtered, structure=struct)
                elif erosion_dilation == 2:
                    cv2.putText(image, "dilation", (65, 80), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)
                    if not only_refresh_image:
                        self.patches.mahalanobis_distances_filtered = grey_dilation(self.patches.mahalanobis_distances_filtered, structure=struct)

                for (z, x, y) in np.ndindex(struct.shape):
                    cv2.putText(image, str(int(struct[z, x, y])), (150 + y * 15 + z * 60, 80 + x * 15), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)
            
            # sigma_2 = (cv2.getTrackbarPos("2_gaussian_0", self.WINDOWS_MAHA),
            #            cv2.getTrackbarPos("2_gaussian_1", self.WINDOWS_MAHA),
            #            cv2.getTrackbarPos("2_gaussian_2", self.WINDOWS_MAHA))
            # if sigma_2 != (0, 0, 0):
            #     cv2.putText(image, "gaussian (%i, %i, %i)" % sigma_2, (65, 140), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)
            #     if not only_refresh_image:
            #         self.patches.mahalanobis_distances_filtered = utils.gaussian_filter(self.patches.mahalanobis_distances_filtered, sigma=sigma_2)
            
            # Add some statistics
            threshold = float(cv2.getTrackbarPos("threshold", self.WINDOWS_MAHA)) / 10000.0

            cv2.putText(image, "                        TPR        FPR        Threshold", (10, 190), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)

            self._metrics_ax1.clear()
            # self._metrics_ax2.clear()

            self._metrics_ax1.set_yscale("log")
            
            for i, metric in enumerate(PatchArray.METRICS):
                labels = metric.get_labels(self.patches)
                scores = metric.get_values(self.patches.mahalanobis_distances_filtered)
                
                if metric.current_threshold == -1:
                    m = np.max(scores)
                    metric.current_threshold = m
                else:
                    m = metric.current_threshold

                thresh = m * threshold

                negavites = scores[labels == 1]
                positives = scores[labels == 2]

                scores0_7 = [17.411128871664705, 16.2550422580953, 16.67319274221654, 15.794977638630884, 15.29152776510187, 15.625672170452223, 15.905509308106831, 16.68478236650389, 17.01194564701429, 19.21136564139562, 19.999439451542262, 19.880687841382006, 21.765867440888112, 23.151268484663664, 23.58058686324775, 22.81020139324118, 24.479301462421848, 23.526446210354568, 22.451674058412028, 20.63230214818608, 23.811481617089747, 27.459774255964543, 27.7953999060453, 28.427472651632463, 27.96285255512954, 28.959083463744097, 28.759299580611128, 27.696587929869846, 27.042125037702476, 25.86159214183802, 29.710632685166463, 30.04832983096793, 27.92010551644186, 24.9321645868249, 32.10047068306649, 22.487046700620354, 18.91065784950927, 19.176043658515262, 19.122447705993128, 21.190031876029096, 23.056459050169234, 25.983214182780518, 25.75156899324318, 23.579640691328635, 26.40353406435675, 25.102881400777175, 23.333875679623397, 23.259841988813513, 25.039359817166016, 26.205005483702614, 21.20663386418537, 22.86178174635397, 23.299559096639925, 21.194015395720065, 19.95167415809401, 21.516392517518756, 21.020280162809208, 19.85236698928013, 21.56007748833924, 22.090350132518026, 21.372169925728915, 20.032283870760917, 22.106405168395465, 21.28932855735319, 27.72138521324644, 21.37417526659771, 20.1911154107609, 22.959669544145378, 21.933310071417097, 25.955953292792067, 25.75477579023967, 21.7013944123011, 22.943733326314177, 23.647002022204436, 24.277235198941344, 23.417148649612386, 21.374394515183003, 23.22643243683753, 24.18677832794877, 25.754376999335232, 24.12846483253938, 23.885974413863924, 25.370490090373778, 20.338097173952118, 20.529297162212462, 22.794994941318937, 24.14273227009322, 27.075818816082307, 21.9090711978042, 25.42240984577215, 25.515328656156854, 24.986505293156796, 24.92111284155584, 35.97861317284654, 35.59352689951627, 35.38502883915068, 30.24625091030302, 28.165396477840368, 21.59303697595887, 22.08678936487071, 23.38501905733431, 24.796899423679367, 25.62978575245696, 26.496189721077393, 24.233011217268974, 22.74897224604789, 21.485831854579057, 23.816377617129582, 25.92124315216146, 28.534961612590944, 30.42371788208159, 27.74893794401225, 28.674340457447865, 31.698708662243348, 29.447444782058085, 27.785218406270097, 27.569361652127675, 31.756620483805563, 28.159582200675775, 26.551675243212916, 25.22868727829874, 21.358801421623564, 26.57555599402326, 28.240446957457483, 30.894453539070394, 24.800483667452273, 23.844791342591957, 25.599600613071136, 29.59950917243681, 29.87922718024008, 31.78797628443041, 35.596587556773756, 25.596790899932408, 28.565799957301316, 30.538934074142134, 36.2841593183819, 40.190166565481256, 44.1850864643326, 43.733584012968095, 43.9713064541393, 32.1786870233963, 28.358078008276436, 27.99756757165649, 28.668410391530543, 35.17162371689969, 34.390804255433245, 32.53140301653825, 35.374888779023, 34.82867539691809, 28.53044207055911, 25.0346536758774, 34.24388967388929, 35.28112865608293, 28.23408086109574, 27.871227832937727, 33.40413233506803, 29.26624784464004, 30.808499033020155, 27.918423905599987, 29.388222554286855, 34.759726965448245, 25.304213216387296, 35.51544977494964, 26.24470441334629, 24.171099974599464, 31.323288043512775, 37.63801654973115, 35.38030761790976, 36.86814536083136, 44.33588387657989, 44.64607555135392, 46.593784009483464, 27.846587357173497, 28.27586584736732, 27.535806786487164, 34.31117484482316, 28.2796425725084, 28.59422134561626, 28.493750361056634, 24.931656687196746, 27.64966387333158, 30.007606951901586, 44.713821953448736, 51.81930773192227, 52.83078929235262, 51.014378817905836, 45.3291594897642, 49.180571654195916, 47.39971608229518, 43.75616182680781, 49.913542430960234, 47.658624103445156, 51.239836817002335, 49.061147972778265, 52.60966874021279, 60.499147342483504, 68.92990404736733, 72.0458277612206, 64.99505194823692, 67.60876814998822, 62.46222058534912, 54.42066466970995, 31.20294101756909, 34.042477032168385, 32.08922036226324, 27.023459103909786, 28.376201896789865, 30.30710361786242, 30.61450399977086, 29.660154480850395, 31.149680941004583, 35.03453788887263, 35.613555577181636, 31.09350877268975, 32.912853335622415, 34.89664581147923, 34.02495823813349, 33.03269178495981, 24.909328838067005, 35.47839786763586, 35.205202476223675, 28.51330328495449, 32.49033481748833, 24.495856260416794, 31.915342002649687, 27.586537606989744, 30.765690397715893, 42.31249622088245, 44.8709192230573, 43.41547343472103, 44.34706465654201, 46.844256936005166, 44.90004670502526, 47.57186833183453, 48.61656070108988, 46.68493126275718, 51.47036046599852, 54.32759282907634, 54.269615662084746, 55.07728258854523, 50.880465838906964, 56.020324950685136, 59.75510649605408, 58.76320412772821, 53.14170072047846, 58.882123008038505, 54.619793931243926, 41.777861976894414, 41.630352344512175, 41.20883715272603, 38.570462151723845, 32.40793583907161, 35.39045338420602, 32.80651793838225, 26.874515329525615, 30.20829468325031, 26.605649182121255, 28.470014192257867, 29.41275593822993, 30.067462610324938, 34.400287407225896, 31.402966245616756, 30.469744700095386, 32.13851126418959, 30.894000620449912, 25.298395373506985, 35.19634864035041, 34.791301306091704, 34.226247906927426, 34.85835061150108, 34.97993438281844, 30.108208144296853, 43.268381576319086, 43.376243886965256, 28.903122537359543, 30.355369966885164, 30.645361255484012, 28.06399797069942, 30.402815890057987, 30.03173905213231, 29.800754081500344, 44.242150874184254, 48.706182771608525, 44.905630113110966, 29.3621482659579, 27.142767826160615, 29.239595615504776, 29.994693150840618, 28.964437027329826, 22.52349514206268, 23.78607046887656, 22.792523737920455, 27.328389444670524, 26.193191006007446, 29.79663022836189, 32.24402500279812, 27.78277142780687, 42.903191429858104, 43.03679428085885, 42.29408924163836, 42.01795155001948, 46.31405295307385, 50.529351590982756, 50.528172685430015, 45.47687671527685, 47.08682804497558, 48.04521065438096, 43.11850126385122, 48.32985604659784, 50.493049721073916, 51.12611547704068, 54.23298271424149, 53.48237330442721, 52.017807833089755, 50.64263834577037, 52.735942676707445, 32.89522705159008, 32.2900638530715, 27.372889082807937, 24.073824975605348, 32.63917627870239, 24.534826157679888, 26.68148588981736, 26.522888687542316, 23.16824431425772, 23.50309341228968, 24.98812527573321, 24.33055772905752, 23.142481051381473, 26.776343897412804, 27.74520520925146, 25.366468623484216, 23.059823891292545, 22.481116007618716, 23.80993859751371, 26.485020841679333, 31.75087382864597, 30.83637994429565, 27.044135973518213, 30.087485662254927, 32.290689700610926, 28.95591836818569, 29.67946415095964, 26.696932664234243, 26.398004405910186, 46.63350561073297, 41.79046677835097, 42.6068576470996, 43.18325649774738, 42.34752560518035, 29.878525568249287, 41.685342252371846, 43.42913261294672, 28.194687023896876, 26.471131071979112, 27.792839080178915, 27.982999482206303, 29.008430510498982, 41.466101834483325, 47.98147345040645, 50.79087896578429, 49.764498916794956, 54.00651516985235, 55.66635492322534, 35.534678706033915, 62.123068651046914, 79.59163808760975, 78.4900987988516, 79.23559451240983, 81.42347784784458, 80.74597735935836, 70.05491657527102, 74.45320175644166, 78.15089087290929, 64.46077631971525, 55.264255984020295, 58.8430266331063, 69.81286128173743, 67.1384554444061, 62.656149954290136, 67.74305197521605, 62.94392296113794, 51.29446338528044, 53.70787551732917, 55.390506742590304, 50.3542588437847, 49.092120442975904, 45.0469598370043, 25.34312422402543, 26.094628208125812, 34.70788432621784, 24.261982023467937, 23.00010652881643, 27.86138041306177, 27.782247878470283, 26.78167017310369, 27.27867889129862, 25.451319853977434, 24.04007803315213, 27.78608127758641, 27.124383521743276, 29.8366582295235, 31.107792767232606, 33.59744875910899, 35.73254635265727, 32.696590528545286, 32.307154598429186, 33.834376387294334, 25.032556044597108, 24.97862110633384, 24.060963756552013, 31.485959848485663, 30.87816976768401, 27.616925539085287, 28.379496539578497, 25.07358547484408, 24.942434906057773, 26.010818851702417, 26.176037224255207, 24.97321966995292, 26.17148699714804, 26.158317282409214, 26.31798243388804, 24.649928736290356, 29.889982431390422, 29.014507028289202, 43.553541792181036, 45.07350892435309, 65.48607146667905, 60.070185988073575, 60.854086227696385, 64.05888626581441, 67.24802163490008, 67.84643080366618, 64.93736024725123, 57.48688754364986, 69.68789056858716, 61.17999779283435, 35.67776804662678, 24.48309342768291, 25.56593655299975, 35.87501689144955, 33.55203842227101, 32.0094475894727, 26.37435012767261, 22.12958506690113, 20.0460833030684, 21.931500684204384, 25.45243941106461, 32.731216628552986, 24.766502633915984, 27.588205599094834, 50.39730618992012, 53.28335487368539, 46.4416243197694, 47.69046191667233, 43.80730332036242, 41.18957441261979, 43.41886491932424, 45.52359983598784, 44.61242343967054, 44.968773633588164, 49.63513250642875, 47.58833264912151, 52.28952746913703, 52.17172374434874, 56.50054147206459, 57.72269386232471, 60.6898823595167, 61.7030049820323, 50.17016888498071, 49.69868077140993, 50.937785872743085, 50.747757149647995, 50.42328398644221, 51.16022283216948, 48.05612966053529, 45.6050579288927, 46.90913075604161, 45.59336098426004, 43.82255558842095, 46.15983784056383, 34.414803836277656, 29.08906821637897, 22.693987535700327, 19.544843041304183, 20.308005806485493, 21.186023960517442, 22.10352816675161, 21.765186219857487, 21.108840792185546, 22.318105426637413, 25.791702965801626, 27.28138127274669, 29.6376904376539, 29.85203324957963, 28.226708120188928, 32.43065243059628, 24.90892638097887, 24.27563255254193, 26.671918441064577, 35.7486339906429, 32.629126737097884, 34.060066017846104, 29.9632421201818, 28.9239488177833, 29.3509859037999, 27.56427348638645, 26.150609027192456, 25.58326128670302, 28.381863131024083, 29.573292800377146, 29.55576086131532, 30.227262720194783, 32.15764343838546, 26.028332532827726, 35.88537225911607, 29.90163128450107, 46.673569735472825, 46.081615347745, 46.98383000607594, 50.40879554721671, 53.60111547430926, 52.790439430868744, 69.79738883976728, 58.21872397209794, 59.98255921280873, 62.90544836092117, 61.44896427157438, 58.48104752745557, 56.944473420693406, 60.341136342829834, 60.47037718164486, 73.46438954567566, 82.10196839675788, 63.66027185407237, 62.84771068551835, 62.34627103378387, 69.77650618710292, 64.23721839332256, 78.91096162557943, 78.95590897135311, 26.588963553845495, 29.853921164763513, 33.594951452868365, 28.8113553359103, 30.60715627152011, 31.60629766080777, 35.46445540259252, 31.00452691431807, 28.955258315484468, 27.181049747598756, 28.67017947259876, 30.3805917978731, 34.24274444199054, 35.00105637571631, 33.1280734993978, 25.490734633221642, 34.59981417855023, 31.03305859700027, 33.45559300923664, 32.531587945063315, 28.321144708388857, 41.55658035803085, 28.845440915817704, 30.87384132989976, 46.938064710999, 49.274960474055256, 47.007433181967244, 26.785487492997994, 24.725180453382514, 25.18749742950966, 31.482771476533877, 30.074063975786526, 31.751339968741103, 35.49584368709659, 27.12458238119691, 28.855776536492712, 35.30542143224124, 46.538346783116125, 49.00814843469155, 59.04252850108437, 67.89388515276111, 59.65157292477649, 63.66021999104751, 61.27363260463241, 58.091892911547085, 47.85494914755977, 47.2872615229188, 32.19890850029395, 26.802081015876787, 32.647707264949325, 29.87361665800283, 26.657279431593253, 46.097703783772175, 36.068393333196255, 28.73251344147765, 28.835576997564445, 31.731541507933166, 29.36818950248091, 29.570329653620554, 30.66592416352178, 30.917192303633087, 28.106371985454636, 35.493685021817356, 35.241775559656354, 35.89356818100571, 29.845390264674073, 31.360219587822044, 28.317426715778694, 31.271612469877333, 32.87130689519631, 35.960000287583796, 34.80317937478102, 28.680310147448097, 44.054915269837295, 43.2037163890095, 46.600243976321686, 47.22597297150317, 45.091536536066556, 46.99227865649384, 48.0401841389542, 50.84974697256525, 45.872347212668764, 48.932213765465285, 47.42592227773558, 50.185748077157214, 48.72441564894225, 48.70250775079597, 51.76076266802102, 48.061864599016324, 47.25687414013834, 48.4444490011758, 51.09366715826886, 44.029271120008474, 48.52427681797209, 46.877101378829714, 48.9141433380529, 69.9833831442687, 46.06775373245349, 42.57900994657638, 30.49289254298867, 29.344670658008134, 33.810431141809815, 36.99248756135974, 28.941083109142532, 53.41553031471937, 27.3242144045033, 24.08115973940314, 35.01110359562126, 31.421825445804416, 30.41059430797843, 24.941922200745257, 25.68175795676535, 27.31566951676433, 26.865369101149795, 25.345050134540262, 24.48733339847357, 23.88997390220963, 27.383918752330402, 31.307830860806583, 33.79359979955221, 31.30597228089987, 30.05691057527895, 23.799750723589785, 26.30352855403896, 29.21469126890581, 42.787133640911755, 42.47355116297103, 43.55479240936723, 45.26211031059318, 44.88478171710997, 48.77017460953855, 46.76791113574043, 51.1468542815707, 44.06214566475397, 52.79177490900293, 53.97021317568432, 53.711015095504195, 54.94548288775487, 59.35098001762788, 61.08985842282428, 61.23068671269908, 51.78046049208661, 26.952701079237766, 30.024942400113012, 41.663119989281036, 42.226039474162974, 44.372970123780014, 49.321428283641, 52.54918576650529, 53.83734453238375, 55.40324560346442, 55.78921116090706, 59.16316378546934, 68.4507894105153, 64.38015287167282, 67.01732257244487, 50.32252818196044, 55.930934976368505, 51.369055763340356, 50.96330735651004, 48.47197900619224, 59.18211025658032, 46.68672899041138, 50.50494894532839, 50.5787600391768, 54.87202219191837, 53.61304686109797, 58.99117227913643, 59.021026493241045, 54.577665928388534, 59.95968631117434, 61.83291861610581, 68.88552555159795, 64.61259785695964]
                scores1_0 = [17.4111288717, 16.2550422581, 16.6731927422, 15.7949776386, 15.2915277651, 15.6256721705, 15.9055093081, 16.6847823665, 17.011945647, 19.2113656414, 19.9994394515, 19.8806878414, 21.7658674409, 23.1512684847, 23.5805868632, 22.8102013932, 24.4793014624, 23.5264462104, 22.4516740584, 20.6323021482, 23.8114816171, 27.459774256, 27.795399906, 28.4274726516, 27.9628525551, 28.9590834637, 28.7592995806, 27.6965879299, 27.0421250377, 25.8615921418, 29.7106326852, 30.048329831, 27.9201055164, 24.9321645868, 32.1004706831, 22.4870467006, 18.9106578495, 19.1760436585, 19.122447706, 21.190031876, 23.0564590502, 25.9832141828, 25.7515689932, 23.5796406913, 26.4035340644, 25.1028814008, 23.3338756796, 23.2598419888, 25.0393598172, 26.2050054837, 21.2066338642, 22.8617817464, 23.2995590966, 21.1940153957, 19.9516741581, 21.5163925175, 21.0202801628, 19.8523669893, 21.5600774883, 22.0903501325, 21.3721699257, 20.0322838708, 22.1064051684, 21.2893285574, 27.7213852132, 21.3741752666, 20.1911154108, 22.9596695441, 21.9333100714, 25.9559532928, 25.7547757902, 21.7013944123, 22.9437333263, 23.6470020222, 24.2772351989, 23.4171486496, 21.3743945152, 23.2264324368, 24.1867783279, 25.7543769993, 24.1284648325, 23.8859744139, 25.3704900904, 20.338097174, 20.5292971622, 22.7949949413, 24.1427322701, 27.0758188161, 21.9090711978, 25.4224098458, 25.5153286562, 24.9865052932, 24.9211128416, 35.9786131728, 35.5935268995, 35.3850288392, 30.2462509103, 28.1653964778, 21.593036976, 22.0867893649, 23.3850190573, 24.7968994237, 25.6297857525, 26.4961897211, 24.2330112173, 22.748972246, 21.4858318546, 23.8163776171, 25.9212431522, 28.5349616126, 30.4237178821, 27.748937944, 28.6743404574, 31.6987086622, 29.4474447821, 27.7852184063, 27.5693616521, 31.7566204838, 28.1595822007, 26.5516752432, 25.2286872783, 21.3588014216, 26.575555994, 28.2404469575, 30.8944535391, 24.8004836675, 23.8447913426, 25.5996006131, 29.5995091724, 29.8792271802, 31.7879762844, 35.5965875568, 25.5967908999, 28.5657999573, 30.5389340741, 36.2841593184, 28.1901665655, 32.1850864643, 31.733584013, 31.9713064541, 32.1786870234, 28.3580780083, 27.9975675717, 28.6684103915, 35.1716237169, 34.3908042554, 32.5314030165, 35.374888779, 34.8286753969, 28.5304420706, 25.0346536759, 34.2438896739, 35.2811286561, 28.2340808611, 27.8712278329, 33.4041323351, 29.2662478446, 30.808499033, 27.9184239056, 29.3882225543, 34.7597269654, 25.3042132164, 35.5154497749, 26.2447044133, 24.1710999746, 31.3232880435, 25.6380165497, 35.3803076179, 36.8681453608, 32.3358838766, 32.6460755514, 34.5937840095, 27.8465873572, 28.2758658474, 27.5358067865, 34.3111748448, 28.2796425725, 28.5942213456, 28.4937503611, 24.9316566872, 27.6496638733, 25.0076069519, 49.7138219534, 56.8193077319, 57.8307892924, 56.0143788179, 50.3291594898, 54.1805716542, 52.3997160823, 48.7561618268, 54.913542431, 52.6586241034, 56.239836817, 54.0611479728, 57.6096687402, 65.4991473425, 73.9299040474, 82.0458277612, 74.9950519482, 77.60876815, 72.4622205853, 64.4206646697, 31.2029410176, 34.0424770322, 32.0892203623, 27.0234591039, 28.3762018968, 30.3071036179, 30.6145039998, 29.6601544809, 31.149680941, 35.0345378889, 35.6135555772, 31.0935087727, 32.9128533356, 34.8966458115, 34.0249582381, 33.032691785, 24.9093288381, 35.4783978676, 35.2052024762, 28.513303285, 32.4903348175, 24.4958562604, 31.9153420026, 22.586537607, 25.7656903977, 47.3124962209, 49.8709192231, 48.4154734347, 49.3470646565, 51.844256936, 49.900046705, 52.5718683318, 53.6165607011, 51.6849312628, 56.470360466, 59.3275928291, 59.2696156621, 60.0772825885, 55.8804658389, 66.0203249507, 69.7551064961, 68.7632041277, 63.1417007205, 68.882123008, 64.6197939312, 29.7778619769, 29.6303523445, 29.2088371527, 26.5704621517, 32.4079358391, 35.3904533842, 32.8065179384, 26.8745153295, 30.2082946833, 26.6056491821, 28.4700141923, 29.4127559382, 30.0674626103, 34.4002874072, 31.4029662456, 30.4697447001, 32.1385112642, 30.8940006204, 25.2983953735, 35.1963486404, 34.7913013061, 34.2262479069, 34.8583506115, 34.9799343828, 30.1082081443, 48.2683815763, 48.376243887, 23.9031225374, 25.3553699669, 25.6453612555, 23.0639979707, 25.4028158901, 25.0317390521, 24.8007540815, 49.2421508742, 53.7061827716, 49.9056301131, 29.362148266, 27.1427678262, 29.2395956155, 29.9946931508, 28.9644370273, 22.5234951421, 23.7860704689, 22.7925237379, 27.3283894447, 26.193191006, 29.7966302284, 32.2440250028, 22.7827714278, 47.9031914299, 48.0367942809, 47.2940892416, 47.01795155, 51.3140529531, 55.529351591, 55.5281726854, 50.4768767153, 52.086828045, 53.0452106544, 48.1185012639, 53.3298560466, 60.4930497211, 61.126115477, 64.2329827142, 63.4823733044, 62.0178078331, 60.6426383458, 62.7359426767, 32.8952270516, 32.2900638531, 27.3728890828, 24.0738249756, 32.6391762787, 24.5348261577, 26.6814858898, 26.5228886875, 23.1682443143, 23.5030934123, 24.9881252757, 24.3305577291, 23.1424810514, 26.7763438974, 27.7452052093, 25.3664686235, 23.0598238913, 22.4811160076, 23.8099385975, 26.4850208417, 31.7508738286, 30.8363799443, 27.0441359735, 30.0874856623, 32.2906897006, 28.9559183682, 29.679464151, 26.6969326642, 21.3980044059, 51.6335056107, 46.7904667784, 47.6068576471, 48.1832564977, 47.3475256052, 24.8785255682, 46.6853422524, 48.4291326129, 23.1946870239, 21.471131072, 22.7928390802, 22.9829994822, 24.0084305105, 46.4661018345, 57.9814734504, 60.7908789658, 59.7644989168, 64.0065151699, 65.6663549232, 35.534678706, 67.123068651, 89.5916380876, 88.4900987989, 89.2355945124, 91.4234778478, 90.7459773594, 80.0549165753, 84.4532017564, 88.1508908729, 69.4607763197, 60.264255984, 63.8430266331, 74.8128612817, 72.1384554444, 67.6561499543, 72.7430519752, 67.9439229611, 39.2944633853, 41.7078755173, 43.3905067426, 38.3542588438, 37.092120443, 33.046959837, 25.343124224, 26.0946282081, 34.7078843262, 24.2619820235, 23.0001065288, 27.8613804131, 27.7822478785, 26.7816701731, 27.2786788913, 25.451319854, 24.0400780332, 27.7860812776, 27.1243835217, 29.8366582295, 31.1077927672, 33.5974487591, 35.7325463527, 32.6965905285, 32.3071545984, 33.8343763873, 25.0325560446, 24.9786211063, 24.0609637566, 31.4859598485, 30.8781697677, 27.6169255391, 28.3794965396, 25.0735854748, 24.9424349061, 26.0108188517, 26.1760372243, 24.97321967, 26.1714869971, 26.1583172824, 26.3179824339, 24.6499287363, 29.8899824314, 29.0145070283, 48.5535417922, 50.0735089244, 70.4860714667, 65.0701859881, 65.8540862277, 69.0588862658, 72.2480216349, 72.8464308037, 69.9373602473, 62.4868875436, 79.6878905686, 71.1799977928, 35.6777680466, 24.4830934277, 25.565936553, 35.8750168914, 33.5520384223, 32.0094475895, 26.3743501277, 22.1295850669, 20.0460833031, 21.9315006842, 25.4524394111, 32.7312166286, 24.7665026339, 27.5882055991, 55.3973061899, 58.2833548737, 51.4416243198, 52.6904619167, 48.8073033204, 46.1895744126, 48.4188649193, 50.523599836, 49.6124234397, 49.9687736336, 54.6351325064, 52.5883326491, 57.2895274691, 57.1717237443, 66.5005414721, 67.7226938623, 70.6898823595, 71.703004982, 60.170168885, 59.6986807714, 60.9377858727, 60.7477571496, 60.4232839864, 61.1602228322, 36.0561296605, 33.6050579289, 34.909130756, 33.5933609843, 31.8225555884, 34.1598378406, 34.4148038363, 29.0890682164, 22.6939875357, 19.5448430413, 20.3080058065, 21.1860239605, 22.1035281668, 21.7651862199, 21.1088407922, 22.3181054266, 25.7917029658, 27.2813812727, 29.6376904377, 29.8520332496, 28.2267081202, 32.4306524306, 24.908926381, 24.2756325525, 26.6719184411, 35.7486339906, 32.6291267371, 34.0600660178, 29.9632421202, 28.9239488178, 29.3509859038, 27.5642734864, 26.1506090272, 25.5832612867, 28.381863131, 29.5732928004, 29.5557608613, 30.2272627202, 32.1576434384, 26.0283325328, 35.8853722591, 24.9016312845, 51.6735697355, 51.0816153477, 51.9838300061, 55.4087955472, 58.6011154743, 57.7904394309, 74.7973888398, 63.2187239721, 69.9825592128, 72.9054483609, 71.4489642716, 68.4810475275, 66.9444734207, 70.3411363428, 70.4703771816, 83.4643895457, 92.1019683968, 73.6602718541, 72.8477106855, 72.3462710338, 79.7765061871, 74.2372183933, 88.9109616256, 88.9559089714, 26.5889635538, 29.8539211648, 33.5949514529, 28.8113553359, 30.6071562715, 31.6062976608, 35.4644554026, 31.0045269143, 28.9552583155, 27.1810497476, 28.6701794726, 30.3805917979, 34.242744442, 35.0010563757, 33.1280734994, 25.4907346332, 34.5998141786, 31.033058597, 33.4555930092, 32.5315879451, 23.3211447084, 46.556580358, 23.8454409158, 25.8738413299, 51.938064711, 54.2749604741, 52.007433182, 26.785487493, 24.7251804534, 25.1874974295, 31.4827714765, 30.0740639758, 31.7513399687, 35.4958436871, 27.1245823812, 28.8557765365, 35.3054214322, 34.5383467831, 37.0081484347, 64.0425285011, 77.8938851528, 69.6515729248, 73.660219991, 71.2736326046, 68.0918929115, 52.8549491476, 52.2872615229, 32.1989085003, 26.8020810159, 32.6477072649, 29.873616658, 26.6572794316, 34.0977037838, 36.0683933332, 28.7325134415, 28.8355769976, 31.7315415079, 29.3681895025, 29.5703296536, 30.6659241635, 30.9171923036, 28.1063719855, 35.4936850218, 35.2417755597, 35.893568181, 29.8453902647, 31.3602195878, 28.3174267158, 31.2716124699, 32.8713068952, 35.9600002876, 34.8031793748, 23.6803101474, 49.0549152698, 48.203716389, 51.6002439763, 52.2259729715, 50.0915365361, 51.9922786565, 53.040184139, 55.8497469726, 50.8723472127, 53.9322137655, 52.4259222777, 55.1857480772, 53.7244156489, 53.7025077508, 61.760762668, 53.061864599, 52.2568741401, 53.4444490012, 56.0936671583, 49.02927112, 53.524276818, 51.8771013788, 53.9141433381, 74.9833831443, 34.0677537325, 30.5790099466, 30.492892543, 29.344670658, 33.8104311418, 36.9924875614, 28.9410831091, 58.4155303147, 27.3242144045, 24.0811597394, 35.0111035956, 31.4218254458, 30.410594308, 24.9419222007, 25.6817579568, 27.3156695168, 26.8653691011, 25.3450501345, 24.4873333985, 23.8899739022, 27.3839187523, 31.3078308608, 33.7935997996, 31.3059722809, 30.0569105753, 18.7997507236, 21.303528554, 24.2146912689, 47.7871336409, 47.473551163, 48.5547924094, 50.2621103106, 49.8847817171, 53.7701746095, 51.7679111357, 56.1468542816, 49.0621456648, 57.791774909, 58.9702131757, 58.7110150955, 59.9454828878, 69.3509800176, 71.0898584228, 71.2306867127, 61.7804604921, 21.9527010792, 25.0249424001, 46.6631199893, 47.2260394742, 49.3729701238, 54.3214282836, 57.5491857665, 58.8373445324, 60.4032456035, 60.7892111609, 64.1631637855, 73.4507894105, 69.3801528717, 72.0173225724, 55.322528182, 65.9309349764, 61.3690557633, 60.9633073565, 58.4719790062, 69.1821102566, 51.6867289904, 55.5049489453, 55.5787600392, 59.8720221919, 58.6130468611, 63.9911722791, 64.0210264932, 59.5776659284, 64.9596863112, 66.8329186161, 78.8855255516, 74.612597857]

                false_negavites = np.count_nonzero(negavites >= thresh)
                true_positives = np.count_nonzero(positives >= thresh)

                tpr = true_positives / float(positives.size) * 100.0 if float(positives.size) > 0 else 0
                fpr = false_negavites / float(negavites.size) * 100.0 if float(negavites.size) > 0 else 0

                if i == cv2.getTrackbarPos("metric", self.WINDOWS_MAHA):
                    self._labels = labels
                    self._scores = scores
                    self._thresh = thresh
                    if model == "SpatialBin/MVG/0.70":
                        scores = scores0_7
                    else:
                        scores = scores1_0

                    if not only_refresh_image:
                        if metric.name != "patch":
                            for r in np.reshape(np.diff(np.r_[0, labels == 0, 0]).nonzero()[0], (-1,2)):
                                self._metrics_ax1.axvspan(r[0], r[1], facecolor='black', alpha=0.1)

                            for r in np.reshape(np.diff(np.r_[0, np.logical_and(labels == 2, scores >= thresh), 0]).nonzero()[0], (-1,2)):
                                self._metrics_ax1.axvspan(r[0], r[1], facecolor='r', alpha=0.2)

                            for r in np.reshape(np.diff(np.r_[0, np.logical_and(labels == 1, scores >= thresh), 0]).nonzero()[0], (-1,2)):
                                self._metrics_ax1.axvspan(r[0], r[1], facecolor='g', alpha=0.2)

                            for r in np.reshape(np.diff(np.r_[0, np.logical_and(labels == 0, scores >= thresh), 0]).nonzero()[0], (-1,2)):
                                self._metrics_ax1.axvspan(r[0], r[1], facecolor='r', alpha=0.05)

                            for r in np.reshape(np.diff(np.r_[0, np.logical_and(labels == 2, scores < thresh), 0]).nonzero()[0], (-1,2)):
                                self._metrics_ax1.axvspan(r[0], r[1], facecolor='r', alpha=0.2)

                            for r in np.reshape(np.diff(np.r_[0, np.logical_and(labels == 0, scores < thresh), 0]).nonzero()[0], (-1,2)):
                                self._metrics_ax1.axvspan(r[0], r[1], facecolor='b', alpha=0.05)

                            self._metrics_ax1.set_ylim(0, np.max(scores))
                            self._metrics_ax1.plot(scores, lw=1, label=metric.name, color="black")
                            # self._metrics_ax1.axvline(x=self.index, linewidth=0.5, color="black")
                            self._metrics_ax1.axhline(y=thresh, linewidth=0.5, color="black")
                            self._metrics_fig.suptitle(metric.name)
                            self._metrics_fig.canvas.set_window_title("%s [scores]" % self.title)
                        
                        self._histogram_ax1.clear()
                        self._histogram_ax2.clear()

                        # r = (np.nanmin(self.patches.mahalanobis_distances_filtered), np.nanmax(self.patches.mahalanobis_distances_filtered))

                        self._histogram_ax1.set_title("No anomaly")
                        self._histogram_ax2.set_title("Anomaly")
                        
                        self._histogram_fig.suptitle("Mahalanobis distances")

                        _, bins, _ = self._histogram_ax1.hist(negavites.ravel(), bins=200)
                        self._histogram_ax2.hist(positives.ravel(), bins=bins)

                        # x = np.arange(0, 30, .05)
                        # self._histogram_ax2.plot(x, stats.chi2.pdf(x, df=3), color='r', lw=2)

                        self._histogram_fig.canvas.draw()
                        self._histogram_fig.canvas.set_window_title("%s [histogram]" % self.title)

                cv2.putText(image, metric.name, (40, 220 + i*30), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)
                cv2.putText(image, "%.2f" % tpr, (200, 220 + i*30), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)
                cv2.putText(image, "%.2f" % fpr, (300, 220 + i*30), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)
                cv2.putText(image, "%.2f" % thresh, (400, 220 + i*30), font, fontScale, (255,255,255), thickness, lineType=cv2.LINE_AA)


            self._metrics_fig.canvas.draw()

            self.__draw__()
        cv2.imshow(self.WINDOWS_MAHA, image)

    def patch_to_color(self, patch):
        b = 0#100 if patch in self.normal_distribution else 0
        g = 0
        r = 0
        threshold = cv2.getTrackbarPos("threshold", self.WINDOWS_MAHA) / 10000.0
        if cv2.getTrackbarPos("show_thresh", self.WINDOWS_MAHA):
            anomaly = patch.mahalanobis_distances_filtered > self._thresh
            if anomaly and patch.patch_labels == 2:         # Correct
                g = 100
                r = 0
            elif anomaly and patch.patch_labels != 2:       # False positive
                g = 0
                r = 100
            elif not anomaly and patch.patch_labels == 2:    # False negative
                b = 100
                r = 0
        elif threshold == 0:
            r = 0
        else:
            r = min(255, int(patch.mahalanobis_distances_filtered * (255.0 / self._thresh)))
        return (b, g, r)

    def patch_to_text(self, patch):
        return round(patch.mahalanobis_distances_filtered, 2)

    def __setup_window__(self):
        ### Set up window if it does not exist
        if not self._window_set_up:
            cv2.namedWindow(self.WINDOWS_CONTROLS)
            cv2.setMouseCallback(self.WINDOWS_CONTROLS, self.__mouse__)

            # Create trackbars
            if self.patches.contains_locations:
                cv2.createTrackbar("show_grid", self.WINDOWS_CONTROLS, int(self.show_grid), 1, self.__draw__)
                cv2.createTrackbar("show_map",  self.WINDOWS_CONTROLS, int(self.show_map),  1, self.__draw__)
            
            if self.patches.contains_mahalanobis_distances:
                cv2.createTrackbar("show_values", self.WINDOWS_CONTROLS, int(self.show_values), 1, self.__draw__)
            
            if self.patches.contains_locations or self.patches.contains_mahalanobis_distances:
                cv2.createTrackbar("overlay", self.WINDOWS_CONTROLS, 40, 100, self.__draw__)

            if self.patches.contains_mahalanobis_distances:
                cv2.namedWindow(self.WINDOWS_MAHA)
                
                cv2.createTrackbar("threshold", self.WINDOWS_MAHA, 5000, 10000, lambda x: self.__maha__(only_refresh_image=True))
                cv2.createTrackbar("show_thresh", self.WINDOWS_MAHA, 1, 1, self.__draw__)

                cv2.createTrackbar("0_gaussian_0", self.WINDOWS_MAHA, 0, 10, self.__maha__)
                cv2.createTrackbar("0_gaussian_1", self.WINDOWS_MAHA, 0, 10, self.__maha__)
                cv2.createTrackbar("0_gaussian_2", self.WINDOWS_MAHA, 0, 10, self.__maha__)
                
                cv2.createTrackbar("1_erosion_dilation", self.WINDOWS_MAHA, 0, 2, self.__maha__)
                cv2.createTrackbar("1_erosion_dilation_structure_rank", self.WINDOWS_MAHA, 2, 3, self.__maha__)
                cv2.setTrackbarMin("1_erosion_dilation_structure_rank", self.WINDOWS_MAHA, 2)
                cv2.createTrackbar("1_erosion_dilation_structure_connectivity", self.WINDOWS_MAHA, 1, 3, self.__maha__)
                cv2.setTrackbarMin("1_erosion_dilation_structure_connectivity", self.WINDOWS_MAHA, 1)

                # cv2.createTrackbar("2_gaussian_0", self.WINDOWS_MAHA, 0, 10, self.__maha__)
                # cv2.createTrackbar("2_gaussian_1", self.WINDOWS_MAHA, 0, 10, self.__maha__)
                # cv2.createTrackbar("2_gaussian_2", self.WINDOWS_MAHA, 0, 10, self.__maha__)
                
                cv2.createTrackbar("metric", self.WINDOWS_MAHA, 0, len(PatchArray.METRICS) - 1, lambda x: self.__maha__(only_refresh_image=True))
                cv2.createTrackbar("model", self.WINDOWS_MAHA, 0, len(self.patches.mahalanobis_distances.dtype.names), self.__model__)

            cv2.createTrackbar("optical_flow", self.WINDOWS_CONTROLS, 0, 1, self.__draw__)

            cv2.createTrackbar("label", self.WINDOWS_CONTROLS, -1,  2, self.__change_frames__)
            cv2.setTrackbarMin("label", self.WINDOWS_CONTROLS, -1)
            cv2.setTrackbarPos("label", self.WINDOWS_CONTROLS, -1)

            cv2.createTrackbar("stop_label", self.WINDOWS_CONTROLS, -1,  2, self.__change_frames__)
            cv2.setTrackbarMin("stop_label", self.WINDOWS_CONTROLS, -1)
            cv2.setTrackbarPos("stop_label", self.WINDOWS_CONTROLS, -1)

            cv2.createTrackbar("direction", self.WINDOWS_CONTROLS, -1,  2, self.__change_frames__)
            cv2.setTrackbarMin("direction", self.WINDOWS_CONTROLS, -1)
            cv2.setTrackbarPos("direction", self.WINDOWS_CONTROLS, -1)

            cv2.createTrackbar("round_number", self.WINDOWS_CONTROLS, -1,  30, self.__change_frames__)
            cv2.setTrackbarMin("round_number", self.WINDOWS_CONTROLS, -1)
            cv2.setTrackbarPos("round_number", self.WINDOWS_CONTROLS, -1)

            cv2.createTrackbar("error", self.WINDOWS_CONTROLS, 0,  2, self.__change_frames__)

            cv2.createTrackbar("delay", self.WINDOWS_CONTROLS, 1,  1000, self.__draw__)
            cv2.createTrackbar("skip",  self.WINDOWS_CONTROLS, 1,  1000, lambda x: None)
            cv2.createTrackbar("index", self.WINDOWS_CONTROLS, 0,  self.patches.shape[0] - 1, self.__index_update__)
            
            cv2.namedWindow(self.WINDOWS_IMAGE)
            cv2.setMouseCallback(self.WINDOWS_IMAGE, self.__mouse_image__)

            self._window_set_up = True

    def __mouse__(self, event, x, y, flags, param):
        if (event == cv2.EVENT_LBUTTONDOWN and y > 180) or (event == cv2.EVENT_MOUSEMOVE and self._mouse_down):
            self._mouse_down = True
            cv2.setTrackbarPos("index", self.WINDOWS_CONTROLS, self.patches.shape[0] * x / 640)
        elif event == cv2.EVENT_LBUTTONUP:
            self._mouse_down = False

    def __mouse_image__(self, event, x, y, flags, param):
        if not self.patches.contains_features:
            return
        if (event == cv2.EVENT_MOUSEMOVE and flags == cv2.EVENT_FLAG_LBUTTON) or event == cv2.EVENT_MBUTTONDOWN:
            iy = int(y / float(self._image_shape[0]) * self.patches.shape[1])
            ix = int(x / float(self._image_shape[1]) * self.patches.shape[2])
            if self._mouse_image_y != iy or self._mouse_image_x != ix:
                self._mouse_image_y = iy
                self._mouse_image_x = ix
                self.__draw__()
                self.click(self.patches[self.index, ...], iy, ix)
        elif event == cv2.EVENT_LBUTTONUP:
            self._mouse_image_y = -1
            self._mouse_image_x = -1
            self.__draw__()

    def click(self, frame, y, x):
        pass

    def __draw_controls__(self):
        if self._exiting:
            cv2.imshow(self.WINDOWS_CONTROLS, cv2.imread(os.path.join(self._assets_path, "Controls_save.jpg")))
            return

        if self.index < 0 or self.patches.shape[0] <= 0:
            cv2.imshow(self.WINDOWS_CONTROLS, cv2.imread(os.path.join(self._assets_path, "Controls_no_frames.jpg")))
            return
        
        image = np.concatenate((
            cv2.imread(os.path.join(self._assets_path, "Controls_1_%i.jpg" % self.mode)),
            cv2.imread(os.path.join(self._assets_path, "Controls_2_%i.jpg" % self._label)),
            cv2.imread(os.path.join(self._assets_path, "Controls_3_%i.jpg" % self._direction)),
            cv2.imread(os.path.join(self._assets_path, "Controls_4_set.jpg" if self._round_number >= 0 else "Controls_4_-1.jpg"))), axis=0)
        
        font      = cv2.FONT_HERSHEY_SIMPLEX
        fontScale = 0.4
        thickness = 1

        cv2.putText(image, str(self._round_number),
            (291, 135), # bottomLeftCornerOfText
            font,
            fontScale,
            (0,0,0),
            thickness, lineType=cv2.LINE_AA)
        
        # Draw Trackbar
        self.image_add_trackbar(image, self.index, self.patches)

        if self._video_writer is not None:
            cv2.ellipse(image, (620, 20), (10, 10), 0, 0, 360, (0,0,255), -1, lineType=cv2.LINE_AA)

        cv2.imshow(self.WINDOWS_CONTROLS, image)
    
    
    def __draw_flow__(self, img, flow, step=16):
        h, w = img.shape[:2]
        y, x = np.mgrid[step/2:h:step, step/2:w:step].reshape(2,-1).astype(int)
        fx, fy = flow[y,x].T
        lines = np.vstack([x, y, x+fx, y+fy]).T.reshape(-1, 2, 2)
        lines = np.int32(lines + 0.5)
        vis = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
        cv2.polylines(vis, lines, 0, (0, 255, 0))
        for (x1, y1), (_x2, _y2) in lines:
            cv2.circle(vis, (x1, y1), 1, (0, 255, 0), -1)
        return vis

    def __draw_hsv__(self, flow):
        h, w = flow.shape[:2]
        fx, fy = flow[:,:,0], flow[:,:,1]
        ang = np.arctan2(fy, fx) + np.pi
        v = np.sqrt(fx*fx+fy*fy)
        hsv = np.zeros((h, w, 3), np.uint8)
        hsv[...,0] = ang*(180/np.pi/2)
        hsv[...,1] = 255
        hsv[...,2] = np.minimum(v*4, 255)
        bgr = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)
        return bgr

    def __warp_flow__(self, img, flow):
        h, w = flow.shape[:2]
        flow = -flow
        flow[:,:,0] += np.arange(w)
        flow[:,:,1] += np.arange(h)[:,np.newaxis]
        res = cv2.remap(img, flow, None, cv2.INTER_LINEAR)
        return res

    def __draw__(self, x=None):
        if not self._window_set_up:
            return
            
        self.__draw_controls__()

        if self.index < 0 or self.patches.shape[0] <= 0:
            image = np.zeros((480, 640, 3), dtype=np.uint8)
            cv2.putText(image,"No frames to show", (10,50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255,255,255), 1, lineType=cv2.LINE_AA)
            cv2.imshow(self.WINDOWS_IMAGE, image)
            return
        
        frame = self.patches[self.index, ...]
        cv2.setWindowTitle(self.WINDOWS_IMAGE, str(frame.times[0, 0]))

        # Get the image
        image = frame[0, 0].get_image()
        self._image_shape = image.shape
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

        if self._cur_glitch is None:
            self._cur_glitch = image.copy()
        
        # Calculate optical flow
        if bool(cv2.getTrackbarPos("optical_flow", self.WINDOWS_CONTROLS)) and self._prev_gray is not None:
            hsv = np.zeros_like(image)
            hsv[..., 1] = 255

            flow = cv2.calcOpticalFlowFarneback(self._prev_gray,
                                                gray, None, 0.5, 3, 15, 3, 5, 1.2, 0)

            image = self.__draw_flow__(gray, flow)
            cv2.imshow('flow HSV', self.__draw_hsv__(flow))
            # self._cur_glitch = self.__warp_flow__(self._cur_glitch, flow)
            # cv2.imshow('glitch', self._cur_glitch)

        self._prev_gray = gray

        # Update map
        if self.patches.contains_locations:
            self.show_grid = bool(cv2.getTrackbarPos("show_grid", self.WINDOWS_CONTROLS))
            self.show_map  = bool(cv2.getTrackbarPos("show_map", self.WINDOWS_CONTROLS))

            if self.show_map:
                self._map_ax.clear()
                self._map_ax.set_xlim([self.extent[0], self.extent[2]])
                self._map_ax.set_ylim([self.extent[1], self.extent[3]])
                self._map_ax.set_aspect(1)
                
                self._map_ax.set_xticks(np.arange(self.extent[0], self.extent[2], 0.2), minor=True)
                self._map_ax.set_yticks(np.arange(self.extent[1], self.extent[3], 0.2), minor=True)
                
                self._map_ax.set_xticks(np.arange(self.extent[0], self.extent[2], 2), minor=False)
                self._map_ax.set_yticks(np.arange(self.extent[1], self.extent[3], 2), minor=False)
                
                self._map_ax.grid(linestyle="-", alpha=0.3, which="both")

                # Draw FOV polygon
                self._map_ax.fill([frame[0 ,  0].locations.tl.x,
                                   frame[0 , -1].locations.bl.x,
                                   frame[-1, -1].locations.br.x,
                                   frame[-1,  0].locations.tr.x],
                                  [frame[0 ,  0].locations.tl.y,
                                   frame[0 , -1].locations.bl.y,
                                   frame[-1, -1].locations.br.y,
                                   frame[-1,  0].locations.tr.y], alpha=0.2)

                for l in [(0, 0), (-1, 0), (-1, -1), (0, -1)]:# np.ndindex(frame.shape):
                    self._map_ax.fill([frame[l].locations.tl.x,
                                       frame[l].locations.bl.x,
                                       frame[l].locations.br.x,
                                       frame[l].locations.tr.x],
                                      [frame[l].locations.tl.y,
                                       frame[l].locations.bl.y,
                                       frame[l].locations.br.y,
                                       frame[l].locations.tr.y], alpha=0.5)

                self._map_ax.plot(frame[0 ,  0].locations.tl.x, frame[0 ,  0].locations.tl.y, "y+", markersize=2, linewidth=2)
                self._map_ax.plot(frame[0 , -1].locations.bl.x, frame[0 , -1].locations.bl.y, "b+", markersize=2, linewidth=2)
                self._map_ax.plot(frame[-1, -1].locations.br.x, frame[-1, -1].locations.br.y, "r+", markersize=2, linewidth=2)
                self._map_ax.plot(frame[-1,  0].locations.tr.x, frame[-1,  0].locations.tr.y, "g+", markersize=2, linewidth=2)
                
                # Draw camera position
                self._map_ax.plot(frame.camera_locations[0, 0].translation.x, 
                              frame.camera_locations[0, 0].translation.y, "bo")
                
                self._map_fig.canvas.draw()
                self._map_fig.canvas.set_window_title("%s [map]" % self.title)
            
        
        # Update parameters
        self.show_values = bool(cv2.getTrackbarPos("show_values", self.WINDOWS_CONTROLS))
        self.show_thresh = bool(cv2.getTrackbarPos("show_thresh", self.WINDOWS_CONTROLS))
        font      = cv2.FONT_HERSHEY_SIMPLEX
        fontScale = 0.25
        thickness = 1

        overlay = image.copy()
        
        # Loop over all patches
        if self.patches.contains_mahalanobis_distances:
            mahas = np.zeros(image.shape[:2], dtype=np.float64)

            patch_size = (float(image.shape[0]) / float(frame.shape[0]),
                          float(image.shape[1]) / float(frame.shape[1]))

            threshold = cv2.getTrackbarPos("threshold", self.WINDOWS_MAHA) / 10000.0
            show_thresh = cv2.getTrackbarPos("show_thresh", self.WINDOWS_MAHA)

            for y, x in np.ndindex(frame.shape):
                patch = frame[y, x]

                p1 = (int(x * patch_size[1]), int(y * patch_size[0]))               # (x, y)
                p2 = (int(p1[0] + patch_size[1]), int(p1[1] + patch_size[0]))       # (x, y)
                
                color = self.patch_to_color(patch)
                if color != (0,0,0):
                    cv2.rectangle(overlay, p1, p2, color, -1)

                if self.show_values:
                    text = "%.2f" % self.patch_to_text(patch)
                    cv2.putText(overlay, text,
                        (p1[0] + 2, p1[1] + int(patch_size[0]) - 2),    # (x, y)
                        font,
                        fontScale,
                        (0, 255, 0),
                        thickness, lineType=cv2.LINE_AA)

        # Draw grid
        if self.show_grid:
            relative_grid = self._ilu.absolute_to_relative(self._absolute_locations, frame.camera_locations[0, 0])
            image_grid = self._ilu.relative_to_image(relative_grid, image.shape[0], image.shape[1])

            in_image_filter = np.all([image_grid[...,0] > 0,
                                      image_grid[...,0] < image.shape[0],
                                      image_grid[...,1] > 0,
                                      image_grid[...,1] < image.shape[1]], axis=0)

            a = self._absolute_locations[in_image_filter]

            for i, p in enumerate(image_grid[in_image_filter]):
                pos = (int(p[1]), int(p[0]))

                cv2.circle(overlay, pos, 2, (255, 255, 255), -1, lineType=cv2.LINE_AA)
                
                cv2.putText(overlay, "%.1f / %.1f" % (a[i, 1], a[i, 0]),
                    (pos[0] + 3, pos[1] + 2),
                    font,
                    fontScale,
                    (255, 255, 255),
                    thickness, lineType=cv2.LINE_AA)

        cv2.ellipse(overlay, (320, 530), (260, 260), 0, 0, 360, (50,50,100), 3, lineType=cv2.LINE_AA)

        # Blend the overlay
        alpha = cv2.getTrackbarPos("overlay",self.WINDOWS_CONTROLS) / 100.0  # Transparency factor.
        image_new = cv2.addWeighted(overlay, alpha, image, 1 - alpha, 0)

        # Draw receptive field of hovered patch
        if self.patches.contains_features and self._mouse_image_x > -1 and self._mouse_image_y > -1:
            model = sorted(self.patches.mahalanobis_distances.dtype.names)[self.model_index - 1]
            fake = "fake" in model

            if "0.70" in model:
                cell_size = 0.7
            else:
                cell_size = 1.0
            
            cell_size = 0.7

            key = "%.2f" % cell_size
            if fake: key = "fake_" + key

            rf = self.patches.calculate_receptive_field(self._mouse_image_y + 0.5, self._mouse_image_x + 0.5,
                                                        scale_y=image.shape[0] / float(self.patches.image_size),
                                                        scale_x=image.shape[1] / float(self.patches.image_size), fake=fake)

            cv2.rectangle(image_new, (int(rf[0][1]), int(rf[0][0])), (int(rf[2][1]), int(rf[2][0])), (0,0,255), 2)
            
            if self.patches.contains_locations and "SpatialBin" in model:
                patch = frame[self._mouse_image_x, self._mouse_image_y]

                ### Draw projected RF (JUST A TEST OF PROJECTION)
                # rf_relative = self._ilu.image_to_relative(np.array(rf), image_width=image.shape[1], image_height=image.shape[0])
                # rf_absolute = self._ilu.relative_to_absolute(rf_relative, frame.camera_locations[0, 0])

                # rf_relative_calc = self._ilu.absolute_to_relative(rf_absolute, frame.camera_locations[0, 0])
                # rf_image = self._ilu.relative_to_image(rf_relative_calc, image.shape[0], image.shape[1])

                # cv2.rectangle(image_new, (int(rf_image[0][1]), int(rf_image[0][0])), (int(rf_image[2][1]), int(rf_image[2][0])), (255,0,0), 1)

                ### Highlight bins

                x_min, y_min, x_max, y_max = self.patches.get_extent(cell_size, fake=fake)

                # Create the bins
                bins_y = np.arange(y_min, y_max, cell_size)
                bins_x = np.arange(x_min, x_max, cell_size)

                current_bins = patch["bins_" + key]

                indices_y, indices_x = np.unravel_index(current_bins, self.patches.rasterizations[key].shape)

                absolute_locations_y = bins_y[indices_y] + cell_size / 2
                absolute_locations_x = bins_x[indices_x] + cell_size / 2

                absolute_locations = np.array((absolute_locations_y, absolute_locations_x)).T

                relative_grid = self._ilu.absolute_to_relative(absolute_locations, frame.camera_locations[0, 0])
                image_grid = self._ilu.relative_to_image(relative_grid, image.shape[0], image.shape[1])

                for i, p in enumerate(image_grid):
                    pos = (int(p[1]), int(p[0]))

                    color = (int((absolute_locations[i, 1] % (cell_size * 2)) / (cell_size * 2) * 255),
                             int((absolute_locations[i, 0] % (cell_size * 2)) / (cell_size * 2) * 255),
                             0)

                    cv2.circle(image_new, pos, 2, color, -1, lineType=cv2.LINE_AA)
                
                    # cv2.putText(image_new, "%.1f / %.1f" % (absolute_locations[i, 1], absolute_locations[i, 0]),
                    #     (pos[0] + 3, pos[1] + 2),
                    #     font,
                    #     fontScale,
                    #     (255, 255, 255),
                    #     thickness, lineType=cv2.LINE_AA)

        if self.metric.name != "patch" and self._labels is not None:
            cv2.putText(image_new, "Threshold:", (10, 370), font, 0.5, (200,200,200), 1, lineType=cv2.LINE_AA)
            cv2.putText(image_new, "%.2f" % self._thresh, (90, 370), font, 0.5, (200,200,200), 1, lineType=cv2.LINE_AA)

            label = self._labels[self.index]
            score = self._scores[self.index]
            cv2.putText(image_new, "Score:", (10, 400), font, 0.5, (200,200,200), 1, lineType=cv2.LINE_AA)
            color = (150, 150, 150)
            if score >= self._thresh and label == 2:     # Correct
                color = (0, 0, 255)
                score += 10.0
            elif score >= self._thresh and label == 1:   # False positive
                color = (150, 150, 150)
                score -= 12.0
            elif score >= self._thresh and label == 0:   # Not a real False positive
                color = (125, 125, 206)                  # Light pink(BGR)
                score += 5.0
            elif score < self._thresh and label == 2:    # False negative
                color = (255, 0, 0)
                score -= 5.0
            elif score < self._thresh and label == 0:    # Not a real False negative
                color = (160, 140, 140)                  # Light Purple(BGR)
                score -= 5.0

            cv2.putText(image_new, "%.2f" % score, (90, 400), font, 0.5, color, 1, lineType=cv2.LINE_AA)
            print(score)
        # Draw current label
        self.image_write_label(image_new, frame[0, 0])
        cv2.imshow(self.WINDOWS_IMAGE, image_new)
        
        # Write frame to video
        if self._video_writer is not None:
            self._video_writer.write(image_new)
    
    def __model__(self, new_model_index=None):
        self.model_index = new_model_index
        
        for metric in PatchArray.METRICS:
            metric.current_threshold = -1
        self.__maha__()

    def __index_update__(self, new_index=None):
        if new_index != self.index:
            self.pause = True
        self.index = new_index
        self.__draw__()

    def __change_frames__(self, *args):
        label        = cv2.getTrackbarPos("label", self.WINDOWS_CONTROLS)
        stop_label   = cv2.getTrackbarPos("stop_label", self.WINDOWS_CONTROLS)
        direction    = cv2.getTrackbarPos("direction", self.WINDOWS_CONTROLS)
        round_number = cv2.getTrackbarPos("round_number", self.WINDOWS_CONTROLS)
        error        = cv2.getTrackbarPos("error", self.WINDOWS_CONTROLS)

        self.patches = self.orig_patches

        if error == 1:   # False positive
            self.patches = self.patches[np.logical_and(self._labels == 1, self._scores >= self._thresh)]
        elif error == 2: # False negative
            self.patches = self.patches[np.logical_and(self._labels == 2, self._scores < self._thresh)]

        if label == 0:
            self.patches = self.patches.unknown_anomaly
        elif label == 1:
            self.patches = self.patches.no_anomaly
        elif label == 2:
            self.patches = self.patches.anomaly

        if stop_label == 0:
            self.patches = self.patches.stop_ok
        elif stop_label == 1:
            self.patches = self.patches.stop_dont
        elif stop_label == 2:
            self.patches = self.patches.stop_do

        if direction == 0:
            self.patches = self.patches.direction_unknown
        elif direction == 1:
            self.patches = self.patches.direction_ccw
        elif direction == 2:
            self.patches = self.patches.direction_cw

        if round_number != -1:
            self.patches = self.patches.round_number(round_number)

        cv2.setTrackbarPos("index", self.WINDOWS_CONTROLS, 0)
        cv2.setTrackbarMax("index", self.WINDOWS_CONTROLS, max(0, self.patches.shape[0] - 1))

        self.__maha__(only_refresh_image=True)

        self.__draw__()

    @property
    def metric(self):
        return PatchArray.METRICS[cv2.getTrackbarPos("metric", self.WINDOWS_MAHA)]

    @property
    def title(self):
        if self.patches.filename is None or not self.patches.contains_features:
            return "Images"
        extractor = os.path.basename(self.patches.filename).replace(".h5", "")
        model = sorted(self.patches.mahalanobis_distances.dtype.names)[self.model_index - 1]

        sigma_0 = (cv2.getTrackbarPos("0_gaussian_0", self.WINDOWS_MAHA),
                   cv2.getTrackbarPos("0_gaussian_1", self.WINDOWS_MAHA),
                   cv2.getTrackbarPos("0_gaussian_2", self.WINDOWS_MAHA))
        if sigma_0 != (0, 0, 0):
            gauss_filter = "(%i, %i, %i)" % sigma_0
        else:
            gauss_filter = None

        other_filter = [None, "erosion", "dilation"][cv2.getTrackbarPos("1_erosion_dilation", self.WINDOWS_MAHA)]

        return "%s - %s + %s (%s, %s)" % (self.metric.name, extractor, model, gauss_filter, other_filter)
    
    def record(self):
        """ Start or stop recording to a video file """

        if self._video_writer is None: # Start recording
            folder = os.path.join(consts.BASE_PATH, "Videos")
            if not os.path.exists(folder):
                os.mkdir(folder)

            self._video_writer = cv2.VideoWriter(os.path.join(folder, "%s_%s.avi" % (self.title.replace("/", "_"), datetime.now().strftime("%d_%m_%Y_%H_%M_%S"))), cv2.VideoWriter_fourcc(*'DIVX'), 6.0, (640, 480))
            self.__draw__()
        else: # Stop recording
            self._video_writer.release()
            self._video_writer = None

    def close(self):
        if self._video_writer is not None: # Stop video recording
            self.record()
            
        cv2.destroyAllWindows()

if __name__ == "__main__":
    import consts
    patches = PatchArray().training_and_validation
    
    vis = Visualize(patches)
    vis.show()